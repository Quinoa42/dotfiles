#+title: quinoa42's dotEmacs
#+property: header-args :comments org :results silent
#+property: header-args:emacs-lisp :tangle (concat user-emacs-directory "init.el")
#+startup: indent
#+link: gitlab https://gitlab.com/%s
#+link: github https://www.github.com/%s


Here is a list of blogs / configurations that I've grabbed code from or absorbed ideas from. All of them worth reading.
+ [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][zzamboni's Emacs config file]]
+ [[https://github.com/rafadc/emacs.d/blob/master/settings.org][Rafa’s Emacs settings file]]
+ [[https://ladicle.com/post/config/][Ladicle's Emacs Configuration]]
+ [[https://jamiecollinson.com/blog/my-emacs-config/][Jamie Collinson's Emacs Config]]
+ [[https://github.com/munen/emacs.d/blob/master/configuration.org][munen's Emacs configuration]]
+ [[https://karl-voit.at/2017/06/03/emacs-org/][Karl Voit's Emacs Configuration In Org-mode]] and the [[https://github.com/novoid/dot-emacs][repo]]

* Table of Contents :TOC:
- [[#general-settings][General Settings]]
  - [[#coding-and-languages][Coding and Languages]]
  - [[#tangle-initel][Tangle =init.el=]]
  - [[#some-helpful-defaults][Some helpful defaults]]
- [[#platform-specific][Platform Specific]]
  - [[#all-platforms][All platforms]]
  - [[#macos][MacOS]]
  - [[#windows][Windows]]
  - [[#linux][Linux]]
  - [[#gui][GUI]]
  - [[#tui][TUI]]
- [[#package-management][Package Management]]
  - [[#proxy-archives-and-mirrors][Proxy, Archives and Mirrors]]
  - [[#initialization][Initialization]]
  - [[#use-package][Use-package]]
  - [[#paradox][Paradox]]
- [[#miscs][Miscs]]
  - [[#xdg][Xdg]]
  - [[#editorconfig][Editorconfig]]
- [[#colors][Colors]]
- [[#key-bindings][Key Bindings]]
  - [[#which-key][Which-key]]
  - [[#general][General]]
  - [[#hercules][Hercules]]
  - [[#evil][Evil]]
- [[#ui-enhance][UI Enhance]]
  - [[#helm][Helm]]
  - [[#ivy][Ivy]]
  - [[#undo-tree][Undo-tree]]
- [[#completion][Completion]]
  - [[#company][Company]]
  - [[#company-quickhelp][Company-quickhelp]]
- [[#templates][Templates]]
  - [[#yasnippet][Yasnippet]]
  - [[#yankpad][Yankpad]]
- [[#org-mode][Org Mode]]
  - [[#general-settings-1][general settings]]
  - [[#general-keybindings][general keybindings]]
  - [[#task-management][task management]]
  - [[#babel][babel]]
  - [[#org-brain][org-brain]]
  - [[#org-board][org-board]]
  - [[#deft][deft]]
  - [[#toc-org][toc-org]]
  - [[#style-and-faces][style and faces]]
- [[#magit][Magit]]

* General Settings
** Coding and Languages
Use Utf-8 as the default coding system.
#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8-unix)
#+end_src

** Tangle =init.el=
When there is no =init.el= tangled yet, run =C-c= on this block to generate the first =init.el=.
#+begin_src emacs-lisp
  (let ((src (concat user-emacs-directory "readme.org"))
        (dst (concat user-emacs-directory "init.el")))
    (when (file-newer-than-file-p src dst)
      (call-process
       (concat invocation-directory invocation-name)
       nil nil t
       "-q" "--batch" "--eval" "(require 'ob-tangle)"
       "--eval" (format "(org-babel-tangle-file \"%s\" \"%s\" 'emacs-lisp)" src dst)))
    ;; (require 'bytecomp)
    ;; (byte-recompile-file dst nil 0 t)
    )
#+end_src

** Some helpful defaults
I don't know if there is any who would like the wierd tab-space-hybird indent mode.
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

If this is set to =nil=, hard link to the edited file will point to the backup file after backup process.
#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

Version-controlled backup:
#+begin_src emacs-lisp
  (setq version-control t
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2)
#+end_src

4-space indentation:
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (defvaralias 'c-basic-offset 'tab-width)
  (defvaralias 'cperl-indent-level 'tab-width)
#+end_src
* Platform Specific
This part contains code specific to platforms, usually UI or PATH related.

Here is specific config for each OS:
#+begin_src emacs-lisp :noweb no-export
  (cond ((eq system-type 'windows-nt)
         <<Windows>>
         )
        ((eq system-type 'darwin)
         <<MacOS>>
         )
        ((eq system-type 'gnu/linux)
         <<Linux>>
         ))
#+end_src

Here is specific config for each UI:
#+begin_src emacs-lisp :noweb no-export
  (cond ((display-graphic-p)
         <<Graphic>>
         )
        (t
         <<Console>>
         ))
#+end_src

** All platforms
This is the code snippet that should be shared among all platforms.

It is reasonable to just turn off menu bar because I want to go mouse-less.
#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (column-number-mode 1)
#+end_src

** MacOS
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref MacOS
:END:
I don't have specific code for Mac yet.

** Windows
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Windows
:END:
I don't have specific code for Windows yet.

** Linux
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Linux
:END:
I don't have specific code for Linux yet.

** GUI
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Graphic
:END:
Turn off blink cursor, scroll bar and tool bar:
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
#+end_src

Setting faces:
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :height 140)
  (set-face-attribute 'default nil :font "DejaVuSansMono Nerd Font")
  (set-face-attribute 'variable-pitch nil :weight 'normal :inherit 'default)
  (cond
      ((x-list-fonts   "Lucida Grande")   (set-face-attribute 'variable-pitch nil :font   "Lucida Grande"))
      ((x-list-fonts   "Verdana")         (set-face-attribute 'variable-pitch nil :font   "Verdana"))
      ((x-family-fonts "Sans Serif")      (set-face-attribute 'variable-pitch nil :family "Sans Serif"))
      (nil (warn "Cannot find a Sans Serif Font.")))
  (set-face-attribute 'fixed-pitch nil :inherit 'default)
#+end_src

** TUI
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref Console
:END:
I don't have specific code for TUI yet.

* Package Management
** Proxy, Archives and Mirrors
I use my local proxy to speed up paradox:
#+begin_src emacs-lisp
  (setq url-proxy-services '(("no_proxy" . "^\\(localhost\\|10\\..*\\|192\\.168\\..*\\)")
                             ("http" . "127.0.0.1:8118")
                             ("https" . "127.0.0.1:8118")))
#+end_src

And also, set package archive to include ELPA, MELPA and org's, with TUNA's mirror:
#+begin_src emacs-lisp
  (setq package-archives '(("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
                           ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
                           ("org" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/org/")))
#+end_src

** Initialization
From [[help:package-initialize]]:
#+begin_quote
If called as part of loading ‘user-init-file’, set
‘package-enable-at-startup’ to nil, to prevent accidentally loading
packages twice.
#+end_quote
Thus, I use the following block to load packages:
#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
  (package-initialize)
#+end_src

** Use-package
[[github:jwiegley/use-package][use-package]] is a wonderful package configuration helper (and not a package manager!). If it is not available in the current system, use =M-x package-install RET use-package RET= to fetch it from MELPA.

Now load =use-package=:
#+begin_src emacs-lisp
  (eval-when-compile
    (require 'use-package))
#+end_src

Also, I'd like to turn on =use-package='s statistic recording to see if my config is correctly set up:
#+begin_src emacs-lisp
  (setq use-package-compute-statistics t)
#+end_src

** Paradox
[[github:Malabarba/paradox][Paradox]] is a modernlized emacs' package menu that supports displaying github stars along the entries, filtering and sorting, async installation, etc.

I disabled the github integration because it doesn't seem to work on my machines.
#+begin_src emacs-lisp
  (use-package paradox
    :ensure t
    :commands paradox-list-packages
    :custom
    (paradox-github-token t)
    (paradox-automatically-star nil)
    :config
    (paradox-enable))
#+end_src

* Miscs
** Xdg
Start from Emacs 26, we hav buit-in suport for =xdg=.
Then it will be reasonble to put those annoying but extremely helpful stuff into xdg cache:
#+begin_src emacs-lisp
  (use-package xdg
    :config
    (let ((backup-dir (concat (xdg-data-home) "/emacs/backup/"))
          (autosave-dir (concat (xdg-cache-home) "/emacs/autosave/")))
      (mkdir backup-dir t)
      (mkdir autosave-dir t)
      (setq backup-directory-alist
            `(("." . ,backup-dir)))
      (setq auto-save-file-name-transforms
            `((".*" ,autosave-dir t)))))
#+end_src

** Editorconfig
[[https://editorconfig.org/][editorconfig]] is a very handy tool that standardize how different editors should behave according to different language, including tab width, trailing space and so on. It is not only helpful for team to maintain a codestyle standard, but also a handful tool for people use several different editors / computers, like I do.

[[github:editorconfig/editorconfig-emacs][editorconfig-emacs]] implements its own =editorconfig= core, so It's logical to assume that it works on any platform.
#+begin_src emacs-lisp
  (use-package editorconfig
    :ensure t
    :config
    (editorconfig-mode 1))
#+end_src

* Colors
I'm currently using the emacs port of my vim era favorite, gruvbox:
#+begin_src emacs-lisp
  (use-package gruvbox-theme
    :ensure t
    :config
    (load-theme 'gruvbox t))
#+end_src

* Key Bindings
References:
1. [[https://sam217pa.github.io/2016/09/23/keybindings-strategies-in-emacs/][Keybindings strategies in Emacs]] by Samuel Barreto.
** Which-key
[[github:justbur/emacs-which-key][which-key]] is a minor mode that hints you the keybindings prefixed with what you have typed when you get stucked.
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode +1))
#+end_src
** General
#+begin_quote
A general is a leader. – onioncheese
#+end_quote
[[github:noctuid/general.el][General]] is a, well, general-purpose key-binding interface for emacs.

There is not much config for general yet, besides enable it I simply turn on its [[*Evil][Evil]] integration:
#+begin_src emacs-lisp :noweb yes
  (use-package general
    :ensure t
    :after which-key
    :config
    (general-evil-setup)
    <<general-config>>
    )
#+end_src
** Hercules
- Note taken on [2019-09-15 Sun 13:59] \\
  It does not work too well with ~evil-window-map~, even if =which-key= is set to use minibuffer.
#+begin_quote
An auto-magical, =which-key= based =hydra= banisher.
...
If only there was a way to make a =hydra= without having to list all the bindings explicitly…
Kind of like =which-key=…
#+end_quote
Did you get the idea what [[jjzmajic/hercules.el][hercules]] is used for? neither do I (at the first glance)! In short, by using the power of [[github:justbur/emacs-which-key][which-key]], =hercules= can build a =hydra= when given a keymap.
#+begin_src emacs-lisp
  (use-package hercules
    :ensure t
    :after general)
#+end_src
** Evil
It's name tells everything: the Extensible Vi Layer for Emacs, [[github:emacs-evil/evil][Evil]]. It works pretty well as a Vim simulation, much better than VsCode's or Intellij's. Besides, it is charming combination of Vim's model-based editing with Emacs' keymap system, to some extent, as a personal opinion, better than the native Vim on the model-based editing system.

References:
+ [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid
#+begin_src emacs-lisp :noweb yes
  (use-package evil
    :ensure t
    :demand t
    :init
    <<evil-mode-init>>
    :general
    <<evil-mode-general>>
    :config
    (evil-mode 1))
#+end_src

I don't want to use Vim's insert mode bindings in insert state:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-init
  (general-setq evil-disable-insert-state-bindings t)
#+end_src

Then, given that I'm using emacs' bindings in insert state, there is no point to use the emacs state which is so hard to escape from:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-general
  ([remap evil-emacs-state] 'evil-normal-state)
#+end_src

[[github:christoomey/vim-tmux-navigator][vim-tmux-navigator]]-like window control:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-general
  (general-nmap "C-j" 'evil-window-down)
  (general-nmap "C-k" 'evil-window-up)
  (general-nmap "C-h" 'evil-window-left)
  (general-nmap "C-l" 'evil-window-right)
#+end_src
It's okay to rebind =C-h= because =<F1>= basically does the same thing.

=swiper= has a nice evil integration such that =/= =?= can be replaced with ~'swiper~ ~'swiper-backward~ respectively:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-general
  ([remap evil-ex-search-forward] 'swiper)
  ([remap evil-ex-search-backward] 'swiper-backward)
#+end_src

When =visual-line-mode= is set (especially in =org-mode=), I want Vim to behave as visual lines are normal lines (i.e. bind =j= to =gj= etc)
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-init
  (general-setq evil-respect-visual-line-mode t)
#+end_src

 Somehow =n/N= only jump backward with swiper unless this is set:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-init
  (general-setq evil-search-module 'evil-search)
#+end_src

I use =C-c= as my =leader=:
#+begin_src emacs-lisp :tangle no :noweb-ref general-config
  (general-create-definer my/leader-def
    ;; :prefix my-leader
    :prefix "C-c")
#+end_src
This is a trick where I remap =SPC= to =C-c=, my leader key. In this way, I wrapped all the mode-defined =C-c= prefixed keybindings (they are not _supposed_ to do so btw) as if they were my leader key prefixed, so that when I type =SPC=, =which-key= will show up all of them.
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-general
  (general-nvmap "SPC" (general-simulate-key "C-c"))
#+end_src

Bring my two of my old vim keybindings back, which open newline above/below current line without entering insert state:
#+begin_src emacs-lisp
  (defun my/insert-line-below ()
    "Insert an empty line below the current line."
    (interactive)
      (end-of-line)
      (open-line 1)
      (next-line))

  (defun my/insert-line-above ()
    "Insert an empty line above the current line."
    (interactive)
      (end-of-line 0)
      (open-line 1)
      (next-line))
#+end_src
I use =<leader>o= and =<leader>O= for them because they are close to =o= and =O= respectively:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-general
  (my/leader-def 'normal
    "o" '(my/insert-line-below :which-key t)
    "O" '(my/insert-line-above :which-key t))
#+end_src

*** evil-collection
[[github:emacs-evil/evil-collection][evil-collection]] is a collection of helper functions / settings / etc for things native Evil does bad on.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :custom
    (evil-collection-setup-minibuffer t)
    :config
    (evil-collection-init 'info)
    (evil-collection-init 'custom)
    (evil-collection-init 'dired)
    (evil-collection-init 'minibuffer)
    (evil-collection-init 'helm))
#+end_src

#+begin_quote
=evil-collection= assumes ~evil-want-keybinding~ is set to =nil= and ~evil-want-integration~ is set to =t= before loading =evil= and =evil-collection=.
#+end_quote
#+begin_src emacs-lisp :tangle no :noweb-ref evil-mode-init
  (general-setq evil-want-integration t)
  (general-setq evil-want-keybinding nil)
#+end_src
*** evil-easymotion
[[github:PythonNut/evil-easymotion][evil-easymotion]] is a Evil port of Vim's, well, =easymotion=, which basically works in a way that instead of numbering how many jumps needed, by prefixing motions with a leader key, we use visual hint to go to the place we want. I hadn't tried =easymotion= during my Vim era though, but I like it now. It also provides integration with [[*evil-snipe][evil-snipe]].
#+begin_src emacs-lisp
  (use-package evil-easymotion
    :ensure t
    :demand t
    :after (evil evil-snipe)
    :general
    (evil-snipe-parent-transient-map
     "SPC"
     (evilem-create 'evil-snipe-repeat
                    :bind ((evil-snipe-scope 'buffer)
                           (evil-snipe-enable-highlight)
                           (evil-snipe-enable-incremental-highlight))))
    (my/leader-def 'motion
      "j" (evilem-create 'next-line)
      "j" '(:ignore t :which-key t)
      "k" (evilem-create 'previous-line)
      "k" '(:ignore t :which-key t)
      "e" '(evilem-motion-forward-word-end :which-key t)
      "E" '(evilem-motion-forward-WORD-end :which-key t)
      "g e" '(evilem-motion-backward-word-end :which-key t)
      "g E" '(evilem-motion-backward-WORD-end :which-key t)
      "w" '(evilem-motion-forward-word-begin :which-key t)
      "W" '(evilem-motion-forward-WORD-begin :which-key t)
      "b" '(evilem-motion-backward-word-begin :which-key t)
      "B" '(evilem-motion-backward-WORD-begin :which-key t)
      "n" '(evilem-motion-search-next :which-key t)
      "N" '(evilem-motion-search-previous :which-key t)
      "g" '(:ignore t :which-key t)))
#+end_src
*** evil-snipe
[[github:hlissner/evil-snipe][evil-snipe]] is a Evil port of Vim's =clever-f= and =vim-sneak=. It currently does not support separating the scope for =f/F/t/T= from for =s/S=, which is a little bit annoying.
#+begin_src emacs-lisp
  (use-package evil-snipe
    :ensure t
    :demand t
    :after evil
    :general
    (general-vmap evil-snipe-local-mode-map "z" 'evil-snipe-s)
    (general-vmap 'visual evil-snipe-local-mode-map "Z" 'evil-snipe-S)
    :hook (magit-mode . turn-off-evil-snipe-override-mode)
    :custom
    (evil-snipe-scope 'visible)
    (evil-snipe-repeat-scope 'whole-visible)
    (evil-snipe-spillover-scope 'whole-buffer)
    :config
    (evil-snipe-mode +1)
    (evil-snipe-override-mode +1))
#+end_src

**** evil-find-char-pinyin
[[github:cute-jumper/evil-find-char-pinyin][evil-find-char-pinyin]] is a helper plugin that allow =evil-snipe= to search for Chinese characters with their initial pinyins. For example, with this plugin =smt= could find 明天.

This plugin actually works for native Evil's =f/F/t/T=, but I use it mainly for its integration with =evil-snipe='s motions.
#+begin_src emacs-lisp
  (use-package evil-find-char-pinyin
    :ensure t
    :after (evil evil-snipe)
    :config
    (evil-find-char-pinyin-toggle-snipe-integration t)
    (evil-find-char-pinyin-mode +1))
#+end_src
* UI Enhance
[[https://www.reddit.com/user/GummyKibble/][u/GummyKibble]] has a concise and wise [[https://www.reddit.com/r/emacs/comments/7vcrwo/helm_vs_ivy_what_are_the_differences_what_are_the/dtrc7v5/][comment]] on the comparison between Helm and Ivy:
#+begin_quote
...[T]o me, Helm feels like a replacement for the Emacs UI I’m used to, while Ivy feels like a refinement of it.
#+end_quote
For me Helm fits me better because:
1. I'm new to Emacs anyway, there is no such Emacs UI that I'm used to.
2. During my Vim era I use Shougo's wonderful plugins Unite/Denite, which mimics the logic of Helm, so switching to Emacs with Helm mostly does not require switching my mind model for how to find things.
3. Ivy is new compared with Helm, so it does not have as many add-ons available as Helm.
** Helm
[[github:emacs-helm/helm][Helm]] is a generic incremental completion and selection narrowing framework for Emacs, as what Denite is for [Neo]vim. I currently does not set Helm to be auto-installed, so just install it with =M-x package-install RET helm RET=.

References:
+ [[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/init-helm.el][thierryvolpiatto's helm config]].
+ [[https://tuhdo.github.io/helm-intro.html][A Package in a league of its own: =Helm=]] by Tu Do (tuhdo)
#+begin_src emacs-lisp
  (use-package helm-config
    :demand t
    :general
    ([remap find-file] 'helm-find-files)
    ([remap occur] 'helm-occur)
    ([remap list-buffers] 'helm-buffers-list)
    ([remap dabbrev-expand] 'helm-dabbrev)
    ([remap execute-extended-command] 'helm-M-x)
    :init
    (unless (boundp 'completion-in-region-function)
      (general-def lisp-interaction-mode-map [remap completion-at-point] 'helm-lisp-completion-at-point)
      (general-def emacs-lisp-mode-map       [remap completion-at-point] 'helm-lisp-completion-at-point)))
#+end_src

Turn on helm
#+begin_src emacs-lisp
  (use-package helm-mode
    :config
    (helm-mode 1))
#+end_src
*** swiper-helm
[[github:abo-abo/swiper-helm][swiper-helm]] is a Helm version of [[*swiper][swiper]]. That is, it use Helm as the backend instead of Ivy.
#+begin_src emacs-lisp
  (use-package swiper-helm
    :ensure t
    :after (helm-config swiper)
    :general ("C-s" 'swiper-helm))
#+end_src
** Ivy
[[github:abo-abo/swiper#ivy][ivy]] is yet another generic incremental completion for Emacs.

I don't use heavily on ivy anymore, but I still have it because its the dependency of swiper:
#+begin_src emacs-lisp
  (use-package ivy
    :custom
    (ivy-count-format "(%d/%d) " "the style for displaying current candidate count")
    ;; (enable-recursive-minibuffers t "allow minibuffer cmd in minibuffer")
    )

  ;; (use-package counsel
  ;;   :ensure t
  ;;   :requires ivy
  ;;   )

  ;; (use-package ivy-rich
  ;;   :ensure t
  ;;   :requires ivy
  ;;   :init
  ;;   (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  ;;   :config
  ;;   (ivy-rich-mode 1))
#+end_src

*** swiper
[[github:swiper#swiper][swiper]] is an alternative to Emacs' builtin [[info:emacs#Basic%20Isearch][isearch]]. I use this over other alternatives because it has better integration by default with Evil's (or Vim's) search/substitution system.
#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :demand t
    :after ivy
    :general
    (general-imap ivy-minibuffer-map "C-p" 'ivy-previous-line)
    (general-imap ivy-minibuffer-map "C-n" 'ivy-next-line)
    :commands (swiper swiper-backward))
#+end_src
** Undo-tree
[[https://www.emacswiki.org/emacs/UndoTree][undo-tree]] provides a visualization for the undo history. It is a prereq for [[*Evil][Evil]].
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :demand t
    :init
    (general-setq undo-tree-visualizer-timestamps nil)
    (general-setq undo-tree-visualizer-lazy-drawing t)
    (general-setq undo-tree-visualizer-relative-timestamps nil)
    :general
    (general-mmap undo-tree-visualizer-mode-map
      "t" 'undo-tree-visualizer-toggle-timestamps)
    (my/leader-def 'normal
      "u" 'undo-tree-visualize)
    :config
    (global-undo-tree-mode +1))
#+end_src

* Completion
By completion I mean general text/code autocompletion, as Vim's =deoplete=.
** Company
[[https://company-mode.github.io/][company]] seems the most widely-used text completion framework among the Emacs ecosystem.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :demand t
    :init
    (general-setq company-auto-complete t)
    (general-setq company-auto-complete-chars '(32 40 41 46))
    (general-setq company-require-match nil)
    (general-setq company-idle-delay nil)
    :general
    (general-unbind company-active-map
      "M-n"
      "M-p")
    (company-active-map "C-n" 'company-select-next
                        "C-p" 'company-select-previous
                        "C-h" 'company-quickhelp-manual-begin
                        "ESC" 'company-abort)
    (general-imap
      "C-n" 'company-select-next
      "C-p" 'company-select-previous)
    :config
    (global-company-mode))
#+end_src

** Company-quickhelp
[[github:expez/company-quickhelp][company-quickhelp]] is an add-on for =company= that make use of =popup-el=, which will show doc for current selected entry in a popup view.
#+begin_src emacs-lisp
  (use-package company-quickhelp
    :ensure t
    :after company
    :init
    (general-setq company-quickhelp-delay nil)
    :config
    (company-quickhelp-mode))
#+end_src

* Templates
Templates are always good time savers.
Reference:
[[http://www.howardism.org/Technical/Emacs/templates-tutorial.html][Having Emacs Type for You]] by Howard Abrams
** Yasnippet
[[github:joaotavora/yasnippet][yasnippet]] is a template system for Emacs.
#+begin_src emacs-lisp :noweb yes
  (use-package yasnippet
    :ensure t
    :demand t
    :general
    <<yasnippet-mode-general>>
    :config
    (yas-global-mode +1))
#+end_src

I don't want the default ~yas-minor-mode-map~'s =C-c &= bindings because they conflict with ~org-marking-goto~. Thus I unbind & rebind them into =<leader> y=.
NOTE: I'm using =yankpad= now instead of directly using =yasnippet=, so I commented these bindings out.
#+begin_src emacs-lisp :tangle no :noweb-ref yasnippet-mode-general
  (general-unbind yas-minor-mode-map
    "C-c & C-n"
    "C-c & C-s"
    "C-c & C-v"
    "C-c &"
    "C-c")
  ;; (my/leader-def
  ;;   :states '(normal visual insert)
  ;;   :keymaps 'yas-minor-mode-map
  ;;   "y n" 'yas-new-snippet
  ;;   "y s" 'yas-insert-snippet
  ;;   "y v" 'yas-visit-snippet-file)
#+end_src

** Yankpad
[[github:Kungsgeten/yankpad][yankpad]] is a cool package that expand snippets written in [[*Org Mode][org mode]] and optionally use [[*Yasnippet][yasnippet]] as the backend.
#+begin_src emacs-lisp
  (use-package yankpad
    :ensure t
    :demand t
    :init
    (general-setq yankpad-file (concat user-emacs-directory "yankpad.org"))
    :general
    (my/leader-def '(normal visual)
      "y" 'yankpad-insert)
    (my/leader-def 'insert
      "y" 'yankpad-expand))
#+end_src

* Org Mode
From its website
#+begin_quote
Org mode is for keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system.
#+end_quote
this is only a facial overall summary of what [[https://orgmode.org][org-mode]] is usually used for. It is so powerful that It is one of the reasons I switched from Neovim to Emacs.

Emacs shipped with a relatively old version of =org-mode=, but many MELPA packages depends on the nightly version, thus I'll usually get the newest one from its own archive via =package-install=.
#+begin_src emacs-lisp :noweb yes
  (use-package org
    :pin org
    :ensure t
    :demand t
    :hook
    (org-mode . visual-line-mode)
    (org-mode . variable-pitch-mode)
    :init
    <<org-mode-init>>
    :general
    <<org-mode-general>>
    :custom-face
    <<org-mode-face>>
    :config
    <<org-mode-config>>
    )
#+end_src

** general settings
Turn on =org-indent=, aka clean view by default:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-startup-indented t)
#+end_src

Enforce todo dependencies (i.e. children block their parent)
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-enforce-todo-dependencies t)
#+end_src

I found that usually I have something to say when I closing a task, for example a link to the reproduction note. Thus I'd like to have closing note by default.
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-log-done 'note)
#+end_src

Put newer note at the top:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-reverse-note-order t)
#+end_src

** general keybindings
Global keybindings as recommended in [[https://orgmode.org/manual/Activation.html#Activation][Org Manual]]:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-general
  (my/leader-def 'normal
    "l"  'org-store-link
    "a"  'org-agenda
    "c"  'org-capture)
#+end_src

And of course, =org-mode='s Evil integration:
#+begin_src emacs-lisp :noweb yes
  (use-package evil-org
    :ensure t
    :after (org evil)
    :hook
    (org-mode . (lambda () (evil-org-mode 1)))
    (org-agenda-mode . (lambda () (evil-org-mode 1)))
    :general
    <<evil-org-general>>
    :commands org-agenda
    :config
    (evil-org-set-key-theme)
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

Here are some evil-specific bindings:
#+begin_src emacs-lisp :tangle no :noweb-ref evil-org-general
  (org-src-mode-map [remap evil-write] 'org-edit-src-save)
#+end_src
** task management
I generally follow the GTD way as my task management system.
reference:
+ [[https://hamberg.no/gtd/][GTD in 15 minutes – A Pragmatic Guide to Getting Things Done]] by Erlend Hamberg
+ [[http://www.members.optusnet.com.au/~charles57/GTD/][Emacs, org-mode and Getting Things Done (GTD)]] by Charles Cave

Todo state keywords. The todo state is simple:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-todo-keywords
                '((sequence "TODO(t!)" "ENGAGE(e!)" "WAIT(w@/@)" "|" "DONE(d@)")
                  ("|" "CANCELED(c@)")))
#+end_src

Log into a =LOGBOOK= drawer so that things are folded when we want to read about outcome descriptions
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-log-into-drawer t)
#+end_src

When refiling, log down a timestamp:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-log-refile t)
#+end_src


Now finally, =org-directory= that will be used to look for capture templates:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-directory "~/documents/tracking")
#+end_src

And the list of files/directories I want my agenda to track:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-agenda-files (quote ("~/documents/tracking")))
#+end_src

And a default note file for templates that does not specify a target file:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-default-notes-file "~/documents/tracking/inbox.org")
#+end_src

Archive things into an archive directory:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-archive-location "~/documents/archive/%s_archive::* Archived")
#+end_src

As GTD requires, I want to refile elements to maybe list or next action list:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-refile-targets (quote (("maybe.org" :maxlevel . 2)
                                           ("tasks.org" :level . 1))))
#+end_src

Caputre templates that helps reduce boilerplate:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-capture-templates
                '(("t" "Todo" entry (file+headline "inbox.org" "Tasks")
                   "* TODO %?\n:LOGBOOK:\n- with context %a at %U\n:END:\n")
                  ("b" "Board" entry (file+headline "~/documents/board/board.org" "Uncategorized")
                   "* %?\n:PROPERTIES:\n:URL: %^C\n:END:\n:LOGBOOK:\n- Entered at %U\n:END:\n")
                  ("n" "Note" entry (file+headline "inbox.org" "Notes")
                   "* %?\n:LOGBOOK:\n- Entered at %U\n:END:\n%x")))
#+end_src

** babel
References:
+ [[https://orgmode.org/worg/org-contrib/babel/intro.html][Babel: Introduction]] in worg/org-contrib
+ [[https://orgmode.org/manual/Working-with-Source-Code.html#Working-with-Source-Code][Working with Source Code]] from =org-mode='s manual
+ [[https://howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]] by Howard Abrams
I declared a hydra for =org-babel= to make things easier:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (hercules-def
   :show-funs #'org-babel-enter
   :hide-funs '(org-babel-exit org-babel-tangle)
   :keymap 'org-babel-map
   :transient t)
  (general-def org-mode-map "C-c C-v" #'org-babel-enter)
  (general-def :prefix-map 'org-babel-map
              "q" #'org-babel-exit)
#+end_src

*** ob-dot
=org-babel= integration with =dot= language, i.e the language used in [[https://graphviz.org/][graphviz]]:
#+begin_src emacs-lisp
  (use-package ob-dot
    :after org)
#+end_src

** org-brain
[[github:Kungsgeten/org-brain][org-brain]] implements concept mapping for org mode, and is also a tool to build my own personal wiki.

Enable tracking org heading links using globally unique uids. This is a must-have even without =org-brain=, because org mode won't fix the broken links when you refile/archive some subtrees to a different file.
#+begin_src emacs-lisp
  (use-package org-id
    :init
    (general-setq org-id-track-globally t))
#+end_src

Now load =org-brain=:
#+begin_src emacs-lisp :noweb yes
  (use-package org-brain
    :ensure t
    :after (evil org)
    :init
    (general-setq org-brain-path "~/documents")
    (general-setq org-brain-title-max-length 30)
    <<org-brain-mode-init>>
    :general
    <<org-brain-mode-general>>
    :custom-face
    <<org-brain-mode-face>>
    )
#+end_src

=org-brain='s keymap conflicts with evil's normal state, so before manually setting the keymaps it might worth simply using emacs-state by default:
#+begin_src emacs-lisp :tangle no :noweb-ref org-brain-mode-init
  (evil-set-initial-state 'org-brain-visualize-mode 'emacs)
#+end_src

Inherit ~org-brain-title~ face from inner-most org-mode heading (so that it won't be over-sized):
#+begin_src emacs-lisp :tangle no :noweb-ref org-brain-mode-face
  (org-brain-title ((t (:inherit org-level-8))))
#+end_src

** org-board
[[github:scallywag/org-board][org-board]] is a helper package that archives web pages locally via =wget=. It enable my personal wiki to save web content so that I can review / grab things later.
#+begin_src emacs-lisp
  (use-package org-board
    :ensure t
    :after org
    :init
    (general-setq org-board-wget-switches
                  '("--page-requisites" "--adjust-extension" "--convert-links"))
    (general-setq org-board-archive-date-format 'hyphenate)
    :ensure t)
#+end_src

** deft
[[https://jblevins.org/projects/deft/][deft]] is not directly related to org mode, but a general purpose plain-text note browser. It works nicely with [[org-brain]] and [[Org Mode]].
#+begin_src emacs-lisp
  (use-package deft
    :ensure t
    :commands (deft)
    :general
    (my/leader-def 'normal
      "d" 'deft)
    :init
    (general-setq deft-directory org-brain-path)
    (general-setq deft-recursive t)
    (general-setq deft-extensions '("org")))
#+end_src

** toc-org
[[github:snosov1/toc-org][toc-org]] will automatically update the content of the first heading with a =:TOC:= tag in an org file to show an up-to-date TOC whenever the file is saved. Handy!
#+begin_src emacs-lisp
  (use-package toc-org
    :ensure t
    :after org
    :hook (org-mode . toc-org-mode))
#+end_src

** style and faces
This part of code is basically grabbed from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][Beautifying Org Mode in Emacs]] by zzamboni.

Hide ===, =~= and other emphasis markers, and fontify src block natively:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-hide-emphasis-markers t)
  (general-setq org-src-fontify-natively t)
  (general-setq org-tags-column 0)
#+end_src

Display =\lambda= etc as their unicode symbols (this works pretty well with embeded LaTeX symbol:
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-init
  (general-setq org-pretty-entities t)
#+end_src

Use =org-bullets= to replace =*= with some cool unicode symbol. This seems super slow on Windows.
#+begin_src emacs-lisp :tangle (unless (eq system-type 'windows-nt) (concat user-emacs-directory "init.el"))
  (use-package org-bullets
    :ensure t
    :after org
    :hook
    (org-mode . (lambda () (org-bullets-mode 1))))
#+end_src

Use different font-size for headers, use sans-serif for non-code-like parts (powered by Emacs!), while still keeping code-like part using monospace font.
#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-face
  (org-level-8               ((t (:inherit variable-pitch :weight bold))))
  (org-level-7               ((t (:inherit org-level-8))))
  (org-level-6               ((t (:inherit org-level-8))))
  (org-level-5               ((t (:inherit org-level-8))))
  (org-level-4               ((t (:inherit org-level-8 :height 1.1))))
  (org-level-3               ((t (:inherit org-level-8 :height 1.25))))
  (org-level-2               ((t (:inherit org-level-8 :height 1.5))))
  (org-level-1               ((t (:inherit org-level-8 :height 1.75))))
  (org-document-title        ((t (:inherit org-level-8 :height 2.0 :underline nil))))
  (org-block                 ((t (:inherit fixed-pitch))))
  (org-document-info         ((t (:foreground "dark orange"))))
  (org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
  (org-link                  ((t (:underline t))))
  (org-meta-line             ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  (org-property-value        ((t (:inherit fixed-pitch))))
  (org-table                 ((t (:inherit fixed-pitch))))
  (org-block-begin-line      ((t (:inherit fixed-pitch :weight bold))))
  (org-block-end-line        ((t (:inherit fixed-pitch :weight bold))))
  (org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  (org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
  (org-verbatim              ((t (:inherit (shadow fixed-pitch)))))
  (org-code                  ((t (:inherit (shadow fixed-pitch)))))
  (org-indent                ((t (:inherit (org-hide fixed-pitch)))))
#+end_src
* Magit
[[github:magit/magit][magit]] is an Emacs interface to git, which provides not only commands to call but also a full GUI-like wrapper around git.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t)
#+end_src

Its Evil integration:
#+begin_src emacs-lisp
  (use-package evil-magit
    :ensure t
    :after (evil magit))
#+end_src
